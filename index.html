<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NDFC - People Network Example</title>
    <script src="./3d-force-graph.js"></script>
    <script src="./force-graph.js"></script>
    <script src="./dat.gui.js"></script>
</head>
<body>
<style>
    body {margin:0;padding:0;}
    .node-label {font-size: 0.3em;}
    .node-img {max-width:20px;border-radius: 20px;}
</style>
<div id="3d-graph"></div>

<script type="importmap">{ "imports": { "three": "./three.module.js" }}</script>
<script type="module">
    // import * as THREE from './three.module.js';
    import { CSS2DRenderer, CSS2DObject } from './CSS2DRenderer.js';
    const container = document.getElementById('3d-graph');

    // controls
    const settings = {
        is2D: false,
    };
    const gui = new dat.GUI();
    gui.add(settings, "is2D")
        .name("2D Mode")
        .onChange(() => {
            console.log("2D Mode checked: ", settings.is2D);
            clearContainer();
            if(settings.is2D){
                init2D();
            }else{
                init3D();
            }
        });


    const imgs = ['cat.jpg', 'dog.jpg', 'eagle.jpg', 'elephant.jpg', 'grasshopper.jpg', 'octopus.jpg', 'owl.jpg', 'panda.jpg', 'squirrel.jpg', 'tiger.jpg', 'whale.jpg'];

    const NODE_REL_SIZE = 1;

    const init3D = () => {
        // const Graph = ForceGraph3D({
        //     extraRenderers: [new CSS2DRenderer()],
        //     antialias: true,
        //     alpha: true })(container)
        //     .linkResolution(6)
        //     .backgroundColor('#101020')
        //     .nodeRelSize(NODE_REL_SIZE)
        //     .nodeColor(() => 'rgba(0,0,0,0)')
        //     // .nodeLabel('name')
        //     .nodeAutoColorBy('group')
        //     .onNodeClick(node => alert('id : ' + node.id + '클릭!'))
        //     .onLinkRightClick(link => alert(link.source.id + ' -> ' + link.target.id))
        //     // .linkDirectionalArrowLength(7)
        //     // .linkDirectionalArrowRelPos(1)
        //     .linkWidth(1)
        //     .linkDirectionalParticles("value")
        //     .linkDirectionalParticleWidth(0.8)
        //     .linkDirectionalParticleSpeed(d => d.value * 0.0005)
        //     .linkColor(link => {
        //         const colors = ['#FFA500', '#E5AE27', '#CCB749', '#B2C06B', '#99C98D', '#7FD2AF', '#66DBD1', '#4CE4F3', '#33EDFF', '#87CEEB'];
        //         return colors[link.value];
        //     })
        //     .onNodeDragEnd(node => {
        //         node.fx = node.x;
        //         node.fy = node.y;
        //         node.fz = node.z;
        //     })
        //     .nodeThreeObject(node => {
        //         const nodeEl = document.createElement('div');
        //         nodeEl.textContent = node.name;
        //         nodeEl.style.color = '#FFF';
        //         nodeEl.className = 'node-label';
        //         const nodeImg = document.createElement('img');
        //         nodeImg.src = `./imgs/${imgs[node.group]}`;
        //         nodeImg.className = 'node-img';
        //
        //         nodeEl.appendChild(nodeImg);
        //
        //         const sprite = new CSS2DObject(nodeEl);
        //         return sprite;
        //     })
        //     .nodeThreeObjectExtend(true);

        const Graph = ForceGraph3D()(containerRef.current)
            .graphData(graphData)
            .nodeLabel(node => `${node.name} (${node.movies} movies)`)
            .nodeColor(() => '#FFA500')
            .nodeVal(node => Math.sqrt(node.movies))
            .linkLabel(link => `${link.movie} (Betweenness: ${link.betweenness.toFixed(2)})`)
            .linkWidth(link => link.betweenness * 2)
            .linkColor(link => {
                const redComponent = Math.floor(link.betweenness * 255);
                return `rgb(${redComponent}, 0, 0)`;
            })
            .nodeThreeObject(node => {
                const sprite = new SpriteText(node.name);
                sprite.color = 'white';
                sprite.textHeight = 8;
                return sprite;
            })
            .nodeThreeObjectExtend(true)
            .d3Force('link')
            .distance(link => 100 / (link.betweenness + 0.1))
            .d3VelocityDecay(0.3);

        // 성능 최적화
        Graph.d3Force('charge').strength(-20);
        Graph.numDimensions(3);
        Graph.dagMode(null);

        fetch('./imdb_actor_network.json').then(res => res.json()).then(data => {
            Graph.graphData(data)
        });
        container._forceGraph = Graph;
        // .nodeThreeObject((node) => {
        //     const group = new THREE.Group();
        //
        //     // 이미지 스프라이트 생성
        //     const imgTexture = new THREE.TextureLoader().load(`https://picsum.photos/50?random=${node.id}`);
        //     imgTexture.colorSpace = THREE.SRGBColorSpace;
        //     const material = new THREE.SpriteMaterial({ map: imgTexture });
        //     const imgSprite = new THREE.Sprite(material);
        //     imgSprite.scale.set(12, 12);
        //
        //     // // 3D 텍스트 생성
        //     // const textGeometry = new TextGeometry(node.name, {
        //     //     font: font,
        //     //     size: 1,
        //     //     height: 0.1,
        //     // });
        //     // const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        //     // const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        //     // textMesh.position.set(-2, -7, 0);  // 이미지 아래에 위치
        //
        //     // 그룹에 이미지와 텍스트 추가
        //     group.add(imgSprite);
        //
        //     return group;
        // });

        // Graph.onEngineStop(() => {
        //     Graph.zoomToFit(400);
        // });
    }

    const init2D = () => {
        const Graph = ForceGraph()(container)
            Graph.nodeId('id')
                .nodeVal('val')
                .nodeLabel('name')
                .nodeAutoColorBy('group')
                .linkSource('source')
                .linkTarget('target')

        fetch('./imdb_actor_network.json').then(res => res.json()).then(data => {
            Graph.graphData(data)
        });

        container._forceGraph = Graph;
    }

    const clearContainer = () => {
        if (container._forceGraph) {
            if (container._forceGraph && typeof container._forceGraph.pauseAnimation === 'function') {
                container._forceGraph.pauseAnimation();
            }
            container._forceGraph._destructor();
        }

        while (container.firstChild) {
            container.removeChild(container.firstChild);
        };
    }

    init3D();

    let allNodes = [];
    let allLinks = [];
    let currentIndex = 0;
    const batchSize = 100;

    // JSON 파일에서 데이터 로드
    async function loadData(url) {
        try {
            const response = await fetch(url);
            const data = await response.json();
            allNodes = data.nodes;
            allLinks = data.links;
            console.log(`Loaded ${allNodes.length} nodes and ${allLinks.length} links`);
            addNextBatch();
        } catch (error) {
            console.error("Error loading data:", error);
        }
    }

    // 다음 배치 데이터 추가
    function addNextBatch() {
        if (currentIndex >= allNodes.length) {
            console.log("All data added");
            return;
        }

        const endIndex = Math.min(currentIndex + batchSize, allNodes.length);
        const newNodes = allNodes.slice(currentIndex, endIndex);
        const newLinks = allLinks.filter(link =>
            newNodes.some(node => node.id === link.source || node.id === link.target)
        );

        Graph.graphData({
            nodes: [...Graph.graphData().nodes, ...newNodes],
            links: [...Graph.graphData().links, ...newLinks]
        });

        currentIndex = endIndex;
        console.log(`Added ${newNodes.length} nodes and ${newLinks.length} links`);

        // 다음 배치 예약
        setTimeout(addNextBatch, 100);
    }

    // 초기 데이터 로드
    // loadData('imdb_actor_network.json');
</script>
</body>
</html>
